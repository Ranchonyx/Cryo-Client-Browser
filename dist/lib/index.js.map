{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/Common/AckTracker/AckTracker.ts", "../../src/Common/CryoBuffer/CryoBuffer.ts", "../../src/Common/Util/Guard.ts", "../../src/Common/CryoBinaryMessage/CryoFrameFormatter.ts", "../../src/Common/CryoFrameInspector/CryoFrameInspector.ts", "../../src/Common/Util/CreateDebugLogger.ts", "../../src/Common/CryoEventEmitter/CryoEventEmitter.ts", "../../src/CryoClientWebsocketSession/CryoCryptoBox.ts", "../../src/CryoClientWebsocketSession/CryoHandshakeEngine.ts", "../../src/CryoClientWebsocketSession/CryoFrameRouter.ts", "../../src/CryoClientWebsocketSession/CryoClientWebsocketSession.ts"],
  "sourcesContent": ["import {CryoClientWebsocketSession} from \"./CryoClientWebsocketSession/CryoClientWebsocketSession.js\";\n\n/**\n * Create a Cryo client\n * @param host - The server to connect to\n * @param bearer - The Bearer token for the server to validate\n * @param use_cale - If cALE (application layer encryption) should be enabled\n * @param timeout - How long to wait until the client stops establishing a connection\n * */\nexport async function cryo(host: string, bearer: string, use_cale: boolean, timeout: number = 5000) {\n    return CryoClientWebsocketSession.Connect(host, bearer, use_cale, timeout);\n}", "import {CryoBuffer} from \"../CryoBuffer/CryoBuffer.js\";\n\ntype PendingBinaryMessage = {\n    timestamp: number;\n    message: CryoBuffer;\n    payload?: string | CryoBuffer;\n}\n\nexport class AckTracker {\n    private pending = new Map<number, PendingBinaryMessage>();\n\n    public Track(ack: number, message: PendingBinaryMessage) {\n        this.pending.set(ack, message);\n    }\n\n    public Confirm(ack: number): PendingBinaryMessage | null {\n        const maybe_ack = this.pending.get(ack);\n        if (!maybe_ack)\n            return null;\n\n        this.pending.delete(ack);\n        return maybe_ack;\n    }\n\n    public Has(ack: number): boolean {\n        return this.pending.has(ack);\n    }\n}\n", "export class CryoBuffer {\n    private view: DataView;\n\n    public constructor(public buffer: Uint8Array) {\n        this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n\n    public static alloc(length: number): CryoBuffer {\n        return new CryoBuffer(new Uint8Array(length));\n    }\n\n    public static from(input: string, encoding?: \"utf8\" | \"hex\"): CryoBuffer {\n        if (encoding === \"utf8\")\n            return new CryoBuffer(new TextEncoder().encode(input));\n\n        const data = new Uint8Array(input.length / 2);\n        for (let i = 0; i < data.length; i++)\n            data[i] = parseInt(input.substring(i * 2, i * 2 + 2), 16);\n\n        return new CryoBuffer(data);\n    }\n\n    public static concat(buffers: CryoBuffer[]): CryoBuffer {\n        if (buffers.length === 0)\n            return CryoBuffer.alloc(0);\n\n        const length_total = buffers.reduce((acc, v) => acc + v.length, 0)\n        const result = new Uint8Array(length_total);\n\n        let offset = 0;\n        for (const buf of buffers) {\n            result.set(buf.buffer, offset);\n            offset += buf.length;\n        }\n\n        return new CryoBuffer(result);\n    }\n\n\n    public writeUInt32BE(value: number, offset: number): void {\n        this.view.setUint32(offset, value);\n    }\n\n    public writeUInt8(value: number, offset: number): void {\n        this.view.setUint8(offset, value);\n    }\n\n    public readUInt32BE(offset: number): number {\n        return this.view.getUint32(offset);\n    }\n\n    public readUInt8(offset: number): number {\n        return this.view.getUint8(offset);\n    }\n\n    public write(text: string, offset: number = 0): void {\n        this.buffer.set(new TextEncoder().encode(text), offset);\n    }\n\n    public set(buffer: CryoBuffer, offset: number): void {\n        this.buffer.set(buffer.buffer, offset);\n    }\n\n    public toString(encoding: \"utf8\" | \"hex\"): string {\n        if (encoding === \"utf8\")\n            return new TextDecoder().decode(this.buffer);\n\n        return [...this.buffer]\n            .map(byte => byte.toString(16).padStart(2, \"0\"))\n            .join(\"\");\n    }\n\n    public subarray(start: number, end?: number): CryoBuffer {\n        return new CryoBuffer(this.buffer.subarray(start, end));\n    }\n\n    public copy(target: CryoBuffer, target_start = 0): void {\n        target.buffer.set(this.buffer, target_start);\n    }\n\n    public get length(): number {\n        return this.buffer.byteLength;\n    }\n}\n", "class GuardError extends Error {\n\tconstructor(pMessage: string) {\n\t\tsuper(pMessage);\n\t\tObject.setPrototypeOf(this, GuardError.prototype);\n\t}\n}\n\n/*\n* Helferklasse mit statischen Funktionen zum \"undefined\" und \"null\"-checken, im Wesentlichen fancy asserts und casts.\n* */\nexport default class Guard {\n\t//wenn \"param\" === null, throw with \"message\"\n\tpublic static AgainstNull<T>(param: T, message?: string): asserts param is Exclude<T, null> {\n\t\tif (param === null)\n\t\t\tthrow new GuardError(message ? message : `Assertion failed, \"param\" (${param}) was null!`);\n\t}\n\n\t//Wenn \"param\" === \"undefined\", throw with \"message\"\n\tpublic static AgainstUndefined<T>(param: T, message?: string): asserts param is Exclude<T, undefined> {\n\t\tif (param === undefined)\n\t\t\tthrow new GuardError(message ? message : `Assertion failed, \"param\" (${param}) was undefined!`);\n\t}\n\n\t//Wenn \"param\" === \"null\" or \"param\" === \"undefined\", throw with \"message\"\n\tpublic static AgainstNullish<T>(param: T, message?: string): asserts param is Exclude<Exclude<T, null>, undefined> {\n\t\tGuard.AgainstUndefined(param, message);\n\t\tGuard.AgainstNull(param, message);\n\t}\n\n\t//Typ von \"param\" als Typ \"T\" interpretieren\n\tpublic static CastAs<T>(param: unknown): asserts param is T {\n\t\tGuard.AgainstNullish(param);\n\t}\n\n\t//Typ von \"param\" als Typ \"T\" interpretieren und \"param\" und \"expr\" gegen \"null\" und \"undefined\" guarden\n\tpublic static CastAssert<T>(param: unknown, expr: boolean, message?: string): asserts param is T {\n\t\tGuard.AgainstNullish(param, message);\n\t\tGuard.AgainstNullish(expr, message);\n\t\tif(!expr)\n\t\t\tthrow new GuardError(`Parameter assertion failed in CastAssert!`);\n\t}\n}\n", "import {CryoBuffer} from \"../CryoBuffer/CryoBuffer.js\";\nimport Guard from \"../Util/Guard.js\";\n\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\ntype Buffer = CryoBuffer;\n\n\nexport enum BinaryMessageType {\n    ACK = 0,\n    ERROR = 1,\n    PING_PONG = 2,\n    UTF8DATA = 3,\n    BINARYDATA = 4,\n    SERVER_HELLO = 5,\n    CLIENT_HELLO = 6,\n    HANDSHAKE_DONE = 7\n}\n\ntype BinaryMessage<T, U extends BinaryMessageType> = {\n    sid: UUID;\n    type: U;\n} & T;\n\ntype AckMessage = BinaryMessage<{\n    ack: number;\n}, BinaryMessageType.ACK>;\n\ntype PingMessage = BinaryMessage<{\n    ack: number;\n    payload: \"ping\" | \"pong\";\n}, BinaryMessageType.PING_PONG>;\n\ntype UTF8DataMessage = BinaryMessage<{\n    ack: number;\n    payload: string;\n}, BinaryMessageType.UTF8DATA>;\n\ntype BinaryDataMessage = BinaryMessage<{\n    ack: number;\n    payload: Buffer;\n}, BinaryMessageType.BINARYDATA>;\n\ntype ErrorMessage = BinaryMessage<{\n    ack: number;\n    payload: \"invalid_operation\" | \"session_expired\" | \"error\";\n}, BinaryMessageType.ERROR>;\n\ntype ServerHelloMessage = BinaryMessage<{\n    ack: number;\n    payload: Buffer;\n}, BinaryMessageType.SERVER_HELLO>\n\ntype ClientHelloMessage = BinaryMessage<{\n    ack: number;\n    payload: Buffer;\n}, BinaryMessageType.CLIENT_HELLO>\n\ntype HandshakeDoneMessage = BinaryMessage<{\n    ack: number;\n    payload: string | null;\n}, BinaryMessageType.HANDSHAKE_DONE>\n\n\ntype CryoAllBinaryMessage =\n    AckMessage\n    | PingMessage\n    | UTF8DataMessage\n    | ErrorMessage\n    | BinaryDataMessage\n    | ServerHelloMessage\n    | ClientHelloMessage\n    | HandshakeDoneMessage;\n\ninterface CryoBinaryFrameFormatter<T extends CryoAllBinaryMessage> {\n    Deserialize(value: Buffer): T;\n\n    Serialize(sid: UUID, ack: number, payload: string | Buffer | null): Buffer;\n}\n\nclass CryoBufferUtil {\n    public static sidFromCryoBuffer(buffer: Buffer): UUID {\n        const uuidv4_p1 = buffer.subarray(0, 4).toString(\"hex\");\n        const uuidv4_p2 = buffer.subarray(4, 6).toString(\"hex\");\n        const uuidv4_p3 = buffer.subarray(6, 8).toString(\"hex\");\n        const uuidv4_p4 = buffer.subarray(8, 10).toString(\"hex\");\n        const uuidv4_p5 = buffer.subarray(10, 16).toString(\"hex\");\n\n        return [uuidv4_p1, uuidv4_p2, uuidv4_p3, uuidv4_p4, uuidv4_p5].join(\"-\") as UUID;\n    }\n\n    public static sidToCryoBuffer(sid: UUID): Buffer {\n        return CryoBuffer.from(sid.replaceAll(\"-\", \"\"), 'hex');\n    }\n}\n\nclass AckFrameFormatter implements CryoBinaryFrameFormatter<AckMessage> {\n    public Deserialize(value: Buffer): AckMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        if (type !== BinaryMessageType.ACK)\n            throw new Error(\"Attempt to deserialize a non-ack binary message!\");\n\n        return {\n            sid,\n            ack,\n            type\n        }\n    }\n\n    // noinspection JSUnusedLocalSymbols\n    public Serialize(sid: UUID, ack: number, payload: string | Buffer | null = null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.ACK, 20);\n        return msg_buf;\n    }\n}\n\nclass PingPongFrameFormatter implements CryoBinaryFrameFormatter<PingMessage> {\n    public Deserialize(value: Buffer): PingMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\");\n        if (type !== BinaryMessageType.PING_PONG)\n            throw new Error(\"Attempt to deserialize a non-ping_pong binary message!\");\n\n        if (!(payload === \"ping\" || payload === \"pong\"))\n            throw new Error(`Invalid payload ${payload} in ping_pong binary message!`);\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: \"ping\" | \"pong\"): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + 4);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.PING_PONG, 20);\n        msg_buf.write(payload, 21);\n\n        return msg_buf;\n    }\n}\n\nclass UTF8FrameFormatter implements CryoBinaryFrameFormatter<UTF8DataMessage> {\n    public Deserialize(value: Buffer): UTF8DataMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\");\n\n        if (type !== BinaryMessageType.UTF8DATA)\n            throw new Error(\"Attempt to deserialize a non-data binary message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: string | null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + (payload?.length || 4));\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.UTF8DATA, 20);\n        msg_buf.write(payload || \"null\", 21);\n\n        return msg_buf;\n    }\n}\n\nclass BinaryFrameFormatter implements CryoBinaryFrameFormatter<BinaryDataMessage> {\n    public Deserialize(value: Buffer): BinaryDataMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21);\n\n        if (type !== BinaryMessageType.BINARYDATA)\n            throw new Error(\"Attempt to deserialize a non-data binary message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: Buffer | null): Buffer {\n        const payload_length = payload ? payload.length : 4;\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + payload_length);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.BINARYDATA, 20);\n        msg_buf.set(payload || CryoBuffer.from(\"null\", \"utf8\"), 21);\n\n        return msg_buf;\n    }\n}\n\nclass ErrorFrameFormatter implements CryoBinaryFrameFormatter<ErrorMessage> {\n    public Deserialize(value: Buffer): ErrorMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\") as ErrorMessage[\"payload\"];\n\n        if (type !== BinaryMessageType.ERROR)\n            throw new Error(\"Attempt to deserialize a non-error message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: ErrorMessage[\"payload\"] | null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + (payload?.length || 13));\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.ERROR, 20);\n        msg_buf.write(payload || \"unknown_error\", 21);\n\n        return msg_buf;\n    }\n}\n\n\nclass ServerHelloFrameFormatter implements CryoBinaryFrameFormatter<ServerHelloMessage> {\n    public Deserialize(value: Buffer): ServerHelloMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21);\n\n        if (type !== BinaryMessageType.SERVER_HELLO)\n            throw new Error(\"Attempt to deserialize a non-server_hello message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: Buffer | null): Buffer {\n        Guard.CastAssert<Buffer>(payload, payload !== null, \"payload was null!\");\n        if (payload.length !== 65)\n            throw new Error(\"Payload in ServerHelloMessage must be exactly 65 bytes!\");\n\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + 65);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.SERVER_HELLO, 20);\n        msg_buf.set(payload, 21);\n\n        return msg_buf;\n    }\n}\n\nclass ClientHelloFrameFormatter implements CryoBinaryFrameFormatter<ClientHelloMessage> {\n    public Deserialize(value: Buffer): ClientHelloMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21);\n\n        if (type !== BinaryMessageType.CLIENT_HELLO)\n            throw new Error(\"Attempt to deserialize a non-client_hello message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: Buffer | null): Buffer {\n        Guard.CastAssert<Buffer>(payload, payload !== null, \"payload was null!\");\n        if (payload.length !== 65)\n            throw new Error(\"Payload in ClientHelloMessage must be exactly 65 bytes!\");\n\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + 65);\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.CLIENT_HELLO, 20);\n        msg_buf.set(payload, 21);\n\n        return msg_buf;\n    }\n}\n\nclass HandshakeDoneFrameFormatter implements CryoBinaryFrameFormatter<HandshakeDoneMessage> {\n    public Deserialize(value: Buffer): HandshakeDoneMessage {\n        const sid = CryoBufferUtil.sidFromCryoBuffer(value);\n        const ack = value.readUInt32BE(16);\n        const type = value.readUInt8(20);\n        const payload = value.subarray(21).toString(\"utf8\");\n\n        if (type !== BinaryMessageType.HANDSHAKE_DONE)\n            throw new Error(\"Attempt to deserialize a non-handshake_done message!\");\n\n        return {\n            sid,\n            ack,\n            type,\n            payload\n        }\n    }\n\n    public Serialize(sid: UUID, ack: number, payload: string | null): Buffer {\n        const msg_buf = CryoBuffer.alloc(16 + 4 + 1 + (payload?.length || 4));\n        const sid_buf = CryoBufferUtil.sidToCryoBuffer(sid);\n\n        sid_buf.copy(msg_buf, 0);\n        msg_buf.writeUInt32BE(ack, 16);\n        msg_buf.writeUInt8(BinaryMessageType.HANDSHAKE_DONE, 20);\n        msg_buf.write(payload || \"null\", 21);\n\n        return msg_buf;\n    }\n}\n\nexport default class CryoFrameFormatter {\n    public static GetFormatter(type: \"utf8data\"): UTF8FrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.UTF8DATA): UTF8FrameFormatter;\n\n    public static GetFormatter(type: \"ping_pong\"): PingPongFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.PING_PONG): PingPongFrameFormatter;\n\n    public static GetFormatter(type: \"ack\"): AckFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.ACK): AckFrameFormatter;\n\n    public static GetFormatter(type: \"error\"): ErrorFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.ERROR): ErrorFrameFormatter;\n\n    public static GetFormatter(type: \"binarydata\"): BinaryFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.BINARYDATA): BinaryFrameFormatter;\n\n    public static GetFormatter(type: \"server_hello\"): ServerHelloFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.SERVER_HELLO): ServerHelloFrameFormatter;\n\n    public static GetFormatter(type: \"client_hello\"): ClientHelloFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.CLIENT_HELLO): ClientHelloFrameFormatter;\n\n    public static GetFormatter(type: \"handshake_done\"): HandshakeDoneFrameFormatter;\n    public static GetFormatter(type: BinaryMessageType.HANDSHAKE_DONE): HandshakeDoneFrameFormatter;\n\n    public static GetFormatter(type: \"utf8data\" | \"ping_pong\" | \"ack\" | \"error\" | \"binarydata\" | \"server_hello\" | \"client_hello\" | \"handshake_done\"): CryoBinaryFrameFormatter<any>;\n    public static GetFormatter(type:\n                                   BinaryMessageType.UTF8DATA |\n                                   BinaryMessageType.PING_PONG |\n                                   BinaryMessageType.ACK |\n                                   BinaryMessageType.ERROR |\n                                   BinaryMessageType.BINARYDATA |\n                                   BinaryMessageType.SERVER_HELLO |\n                                   BinaryMessageType.CLIENT_HELLO |\n                                   BinaryMessageType.HANDSHAKE_DONE): CryoBinaryFrameFormatter<any>;\n    public static GetFormatter(type: string | BinaryMessageType): CryoBinaryFrameFormatter<CryoAllBinaryMessage> {\n        switch (type) {\n            case \"utf8data\":\n            case BinaryMessageType.UTF8DATA:\n                return new UTF8FrameFormatter();\n            case \"error\":\n            case BinaryMessageType.ERROR:\n                return new ErrorFrameFormatter();\n            case \"ack\":\n            case BinaryMessageType.ACK:\n                return new AckFrameFormatter();\n            case \"ping_pong\":\n            case BinaryMessageType.PING_PONG:\n                return new PingPongFrameFormatter();\n            case \"binarydata\":\n            case BinaryMessageType.BINARYDATA:\n                return new BinaryFrameFormatter();\n            case BinaryMessageType.SERVER_HELLO:\n            case \"server_hello\":\n                return new ServerHelloFrameFormatter();\n            case BinaryMessageType.CLIENT_HELLO:\n            case \"client_hello\":\n                return new ClientHelloFrameFormatter();\n            case BinaryMessageType.HANDSHAKE_DONE:\n            case \"handshake_done\":\n                return new HandshakeDoneFrameFormatter();\n            default:\n                throw new Error(`Binary message format for type '${type}' is not supported!`)\n        }\n    }\n\n    public static GetType(message: Buffer): BinaryMessageType {\n        const type = message.readUInt8(20);\n        if (type > BinaryMessageType.HANDSHAKE_DONE)\n            throw new Error(`Unable to decode type from message ${message}. MAX_TYPE = 7, got ${type} !`);\n\n        return type;\n    }\n\n    public static GetAck(message: Buffer): number {\n        return message.readUInt32BE(16);\n    }\n\n    public static GetSid(message: Buffer): UUID {\n        return CryoBufferUtil.sidFromCryoBuffer(message);\n    }\n\n    public static GetPayload(message: Buffer, encoding: \"utf8\" | \"hex\"): string {\n        return message.subarray(21).toString(encoding);\n    }\n}\n", "import CryoFrameFormatter from \"../CryoBinaryMessage/CryoFrameFormatter.js\";\nimport {CryoBuffer} from \"../CryoBuffer/CryoBuffer.js\";\n\nconst typeToStringMap = {\n    0: \"ack\",\n    1: \"error\",\n    2: \"ping/pong\",\n    3: \"utf8data\",\n    4: \"binarydata\",\n    5: \"server_hello\",\n    6: \"client_hello\",\n    7: \"handshake_done\",\n}\n\nexport class CryoFrameInspector {\n    public static Inspect(message: CryoBuffer, encoding: \"utf8\" | \"hex\" = \"utf8\"): string {\n        const sid = CryoFrameFormatter.GetSid(message);\n        const ack = CryoFrameFormatter.GetAck(message);\n        const type = CryoFrameFormatter.GetType(message);\n        const type_str = typeToStringMap[type] || \"unknown\";\n\n        const payload = CryoFrameFormatter.GetPayload(message, encoding);\n\n        return `[${sid},${ack},${type_str},[${payload}]]`\n    }\n}\n", "export type DebugLoggerFunction = (msg: string, ...params: unknown[]) => void;\n\nexport function CreateDebugLogger(section: string): DebugLoggerFunction {\n    if (localStorage.getItem(\"CRYO_DEBUG\")?.includes(section)) {\n        return (msg: string, ...params: unknown[]) => {\n            const err = new Error();\n            const stack = err.stack?.split(\"\\n\");\n            const caller_line = stack?.[2] ?? \"unknown\";\n            const method_cleaned = caller_line.trim().replace(/^at\\s+/, \"\");\n            const method = method_cleaned.substring(0, method_cleaned.indexOf(\"(\") - 1);\n            const position = method_cleaned.substring(method_cleaned.lastIndexOf(\":\") - 2, method_cleaned.length - 1);\n\n            console.info(`${section.padEnd(24, \" \")}${new Date().toISOString().padEnd(32, \" \")} ${method.padEnd(64, \" \")} ${position.padEnd(8, \" \")} ${msg}`, ...params)\n        }\n    }\n\n    return () => {\n    };\n}\n", "import Guard from \"../Util/Guard.js\";\n\nexport class CryoEventEmitter<EventMap extends Record<string, any> = Record<string, any>> {\n    private target = new EventTarget();\n\n    public on<K extends keyof EventMap>(type: K, listener: (payload: EventMap[K]) => void) {\n        Guard.CastAs<string>(type);\n        this.target.addEventListener(type, (e: Event) => {\n            listener((e as CustomEvent).detail);\n        })\n    }\n\n    public emit<K extends keyof EventMap>(type: K, payload: EventMap[K]) {\n        Guard.CastAs<string>(type);\n        this.target.dispatchEvent(new CustomEvent(type, {detail: payload}));\n    }\n}\n", "import {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\r\n\r\ntype Buffer = CryoBuffer;\r\n\r\nasync function import_key(data: Buffer, usage: KeyUsage[]): Promise<CryptoKey> {\r\n    return crypto.subtle.importKey(\r\n        \"raw\",\r\n        data.buffer,\r\n        {name: \"AES-GCM\"},\r\n        false,\r\n        usage\r\n    );\r\n}\r\n\r\nfunction make_algo(iv: Buffer): AesGcmParams {\r\n    return {\r\n        name: \"AES-GCM\",\r\n        iv: iv.buffer,\r\n\r\n    }\r\n}\r\n\r\nexport class CryoCryptoBox {\r\n    private nonce = 0;\r\n\r\n    private readonly enc_key_promise: Promise<CryptoKey>;\r\n    private readonly dec_key_promise: Promise<CryptoKey>;\r\n\r\n    public constructor(encrypt_key: Buffer, decryption_key: Buffer) {\r\n        this.enc_key_promise = import_key(encrypt_key, [\"encrypt\"]);\r\n        this.dec_key_promise = import_key(decryption_key, [\"decrypt\"]);\r\n    }\r\n\r\n    private create_iv(): Buffer {\r\n        const iv = CryoBuffer.alloc(12);\r\n        iv.writeUInt32BE(this.nonce++, 8);\r\n        return iv;\r\n    }\r\n\r\n    public async encrypt(plain: Buffer): Promise<Buffer> {\r\n        const iv = this.create_iv();\r\n        const key = await this.enc_key_promise;\r\n        const encrypted = await crypto.subtle.encrypt(make_algo(iv), key, plain.buffer);\r\n\r\n        return CryoBuffer.concat([iv, new CryoBuffer(new Uint8Array(encrypted))]);\r\n    }\r\n\r\n    public async decrypt(cipher: Buffer): Promise<CryoBuffer> {\r\n        const iv = cipher.subarray(0, 12);\r\n        const key = await this.dec_key_promise;\r\n        const data_with_tag = cipher.subarray(12);\r\n\r\n        const decrypted = await crypto.subtle.decrypt(make_algo(iv), key, data_with_tag.buffer);\r\n\r\n        return new CryoBuffer(new Uint8Array(decrypted));\r\n    }\r\n}", "import CryoFrameFormatter from \"../Common/CryoBinaryMessage/CryoFrameFormatter.js\";\r\nimport {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\r\n\r\ntype Buffer = CryoBuffer;\r\n\r\nexport enum HandshakeState {\r\n    INITIAL = 0,\r\n    WAIT_SERVER_HELLO = 1,\r\n    WAIT_SERVER_DONE = 2,\r\n    SECURE = 3\r\n}\r\n\r\ntype CryptoKeys = { receive_key: Buffer, transmit_key: Buffer };\r\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\r\n\r\nexport interface HandshakeEvents {\r\n    onSecure: (keys: CryptoKeys) => void;\r\n    onFailure: (reason: string) => void;\r\n}\r\n\r\nexport class CryoHandshakeEngine {\r\n    private readonly ECDH_ALGO: EcKeyGenParams = {name: \"ECDH\", namedCurve: \"P-256\"};\r\n    private handshake_state: HandshakeState = HandshakeState.INITIAL;\r\n    private ecdh: CryptoKeyPair | null = null;\r\n    private receive_key: Buffer | null = null;\r\n    private transmit_key: Buffer | null = null;\r\n\r\n    public constructor(\r\n        private readonly sid: UUID,\r\n        private send_plain: (buf: Buffer) => Promise<void>,\r\n        private formatter: typeof CryoFrameFormatter,\r\n        private next_ack: () => number,\r\n        private events: HandshakeEvents\r\n    ) {\r\n        this.init_keys();\r\n    }\r\n\r\n    private async init_keys() {\r\n        try {\r\n            this.ecdh = await crypto.subtle.generateKey(\r\n                this.ECDH_ALGO,\r\n                true,\r\n                [\"deriveBits\"]\r\n            );\r\n            this.handshake_state = HandshakeState.WAIT_SERVER_HELLO;\r\n        } catch (ex) {\r\n            this.events.onFailure(`Failed to generate ECDH keys: ${ex}`);\r\n        }\r\n    }\r\n\r\n    public async on_server_hello(frame: Buffer): Promise<void> {\r\n        if (this.handshake_state !== HandshakeState.WAIT_SERVER_HELLO) {\r\n            this.events.onFailure(`CLIENT_HELLO received while in state ${this.handshake_state}`);\r\n            return;\r\n        }\r\n\r\n        const decoded = CryoFrameFormatter\r\n            .GetFormatter(\"server_hello\")\r\n            .Deserialize(frame);\r\n\r\n        const server_pub_key = await crypto.subtle.importKey(\"raw\", decoded.payload.buffer, this.ECDH_ALGO, false, []);\r\n\r\n        if(!this.ecdh?.privateKey) {\r\n            this.events.onFailure(\"Local ECDH private key not initialised.\");\r\n            return;\r\n        }\r\n\r\n        const secret = await crypto.subtle.deriveBits({name: \"ECDH\", public: server_pub_key}, this.ecdh.privateKey, 256);\r\n        const hash = new Uint8Array(await crypto.subtle.digest(\"SHA-256\", secret));\r\n\r\n        this.transmit_key = new CryoBuffer(hash.subarray(16, 32));\r\n        this.receive_key = new CryoBuffer(hash.subarray(0, 16));\r\n\r\n        const my_pub_key = new CryoBuffer(new Uint8Array(await crypto.subtle.exportKey(\"raw\", this.ecdh.publicKey)));\r\n\r\n        const ack = this.next_ack();\r\n\r\n        const client_hello = this.formatter\r\n            .GetFormatter(\"client_hello\")\r\n            .Serialize(this.sid, ack, my_pub_key);\r\n\r\n        await this.send_plain(client_hello);\r\n        this.handshake_state = HandshakeState.WAIT_SERVER_DONE;\r\n    }\r\n\r\n    /*\r\n    *         if (this.handshake_state !== HandshakeState.WAIT_SERVER_DONE) {\r\n            this.events.onFailure(`HANDSHAKE_DONE received while in state ${this.state}`);\r\n            return;\r\n        }\r\n        console.error(\"CLIENT GOT SERVER HANDSHAKE!\")\r\n        const decoded = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Deserialize(frame);\r\n\r\n        const done = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Serialize(this.sid, decoded.ack, null);\r\n        await this.send_plain(done);\r\n\r\n        this.events.onSecure({receive_key: this.receive_key, transmit_key: this.transmit_key});\r\n        //Client got our SERVER_HELLO and finished on its side\r\n        this.handshake_state = HandshakeState.SECURE;\r\n\r\n    * */\r\n    public async on_server_handshake_done(frame: Buffer): Promise<void> {\r\n        if (this.handshake_state !== HandshakeState.WAIT_SERVER_DONE) {\r\n            this.events.onFailure(`HANDSHAKE_DONE received while in state ${this.state}`);\r\n            return;\r\n        }\r\n\r\n        //Client got our SERVER_HELLO and finished on its side\r\n        //Now we'll send our handshake_done frame\r\n        const decoded = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Deserialize(frame);\r\n\r\n        const done = CryoFrameFormatter\r\n            .GetFormatter(\"handshake_done\")\r\n            .Serialize(this.sid, decoded.ack, null);\r\n        await this.send_plain(done);\r\n\r\n        this.events.onSecure({receive_key: this.receive_key!, transmit_key: this.transmit_key!});\r\n        this.handshake_state = HandshakeState.SECURE;\r\n    }\r\n\r\n    public get is_secure(): boolean {\r\n        return this.handshake_state === HandshakeState.SECURE;\r\n    }\r\n\r\n    public get state(): HandshakeState {\r\n        return this.handshake_state;\r\n    }\r\n}", "import CryoFrameFormatter, {BinaryMessageType} from \"../Common/CryoBinaryMessage/CryoFrameFormatter.js\";\r\nimport {CreateDebugLogger, DebugLoggerFunction} from \"../Common/Util/CreateDebugLogger.js\";\r\nimport {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\r\ntype Buffer = CryoBuffer;\r\n\r\ninterface RouterHandlers {\r\n    //Normal frame routing\r\n    on_ping_pong: (frame: Buffer) => Promise<void>;\r\n    on_ack: (frame: Buffer) => Promise<void>;\r\n    on_error: (frame: Buffer) => Promise<void>;\r\n    on_utf8: (frame: Buffer) => Promise<void>;\r\n    on_binary: (frame: Buffer) => Promise<void>;\r\n\r\n    //Handshake frame routing should go to the HandshakeEngine\r\n    on_server_hello?: (frame: Buffer) => Promise<void>;\r\n    on_client_hello?: (frame: Buffer) => Promise<void>;\r\n    on_handshake_done?: (frame: Buffer) => Promise<void>;\r\n}\r\n\r\nexport class CryoFrameRouter {\r\n    public constructor(\r\n        private readonly formatter: typeof CryoFrameFormatter,\r\n        private readonly is_secure: () => boolean,\r\n        private readonly decrypt: (buffer: Buffer) => Promise<Buffer>,\r\n        private readonly handlers: RouterHandlers,\r\n        private log: DebugLoggerFunction = CreateDebugLogger(\"CRYO_FRAME_ROUTER\")\r\n    ) {\r\n    }\r\n\r\n    private try_get_type(frame: Buffer): BinaryMessageType | null {\r\n        try {\r\n            return CryoFrameFormatter.GetType(frame);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n        /*        if(!buf || buf.length < 21)\r\n                    return null;\r\n\r\n                const type_byte = buf.readUint8(20);\r\n                return type_byte <= BinaryMessageType.HANDSHAKE_DONE ? type_byte as BinaryMessageType : null;*/\r\n    }\r\n\r\n    public async do_route(raw: Buffer): Promise<void> {\r\n        let frame: Buffer = raw;\r\n        let type: BinaryMessageType | null = this.try_get_type(raw);\r\n\r\n        if (type === null && this.is_secure()) {\r\n            try {\r\n                frame = await this.decrypt(raw);\r\n                type = this.try_get_type(frame);\r\n            } catch (e) {\r\n                this.log(`Decryption failed: ${e}`, raw);\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (type === null) {\r\n            this.log(`Unknown frame type`, raw);\r\n            return;\r\n        }\r\n\r\n        switch (type) {\r\n            case BinaryMessageType.PING_PONG:\r\n                await this.handlers.on_ping_pong(frame);\r\n                return;\r\n            case BinaryMessageType.ERROR:\r\n                await this.handlers.on_error(frame);\r\n                return;\r\n            case BinaryMessageType.ACK:\r\n                await this.handlers.on_ack(frame);\r\n                return;\r\n            case BinaryMessageType.UTF8DATA:\r\n                await this.handlers.on_utf8(frame);\r\n                return;\r\n            case BinaryMessageType.BINARYDATA:\r\n                await this.handlers.on_binary(frame);\r\n                return;\r\n            case BinaryMessageType.SERVER_HELLO:\r\n                await this.handlers.on_server_hello?.(frame);\r\n                return;\r\n            case BinaryMessageType.CLIENT_HELLO:\r\n                await this.handlers.on_client_hello?.(frame);\r\n                return;\r\n            case BinaryMessageType.HANDSHAKE_DONE:\r\n                await this.handlers.on_handshake_done?.(frame);\r\n                return;\r\n            default:\r\n                this.log(`Unsupported binary message type ${type}!`);\r\n        }\r\n    }\r\n}", "import {ICryoClientWebsocketSessionEvents, PendingBinaryMessage} from \"./types/CryoClientWebsocketSession.js\";\nimport {AckTracker} from \"../Common/AckTracker/AckTracker.js\";\nimport CryoFrameFormatter, {BinaryMessageType} from \"../Common/CryoBinaryMessage/CryoFrameFormatter.js\";\nimport {CryoFrameInspector} from \"../Common/CryoFrameInspector/CryoFrameInspector.js\";\nimport {CreateDebugLogger, DebugLoggerFunction} from \"../Common/Util/CreateDebugLogger.js\";\nimport {CryoBuffer} from \"../Common/CryoBuffer/CryoBuffer.js\";\nimport {CryoEventEmitter} from \"../Common/CryoEventEmitter/CryoEventEmitter.js\";\nimport {CryoCryptoBox} from \"./CryoCryptoBox.js\";\nimport {CryoHandshakeEngine, HandshakeEvents} from \"./CryoHandshakeEngine.js\";\nimport {CryoFrameRouter} from \"./CryoFrameRouter.js\";\n\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\n\nenum CloseCode {\n    CLOSE_GRACEFUL = 4000,\n    CLOSE_CLIENT_ERROR = 4001,\n    CLOSE_SERVER_ERROR = 4002,\n    CLOSE_CALE_MISMATCH = 4010,\n    CLOSE_CALE_HANDSHAKE = 4011\n}\n\ntype Buffer = CryoBuffer;\n\nfunction once<T extends keyof WebSocketEventMap>(socket: WebSocket, type: T, handler: (ev: WebSocketEventMap[T]) => void) {\n    const wrapper = (ev: WebSocketEventMap[T]) => {\n        socket.removeEventListener(type, wrapper);\n        handler(ev);\n    };\n    socket.addEventListener(type, wrapper);\n}\n\n/*\n* Cryo Websocket session layer. Handles Binary formatting and ACKs and whatnot\n* */\nexport class CryoClientWebsocketSession extends CryoEventEmitter<ICryoClientWebsocketSessionEvents> implements CryoClientWebsocketSession {\n    private messages_pending_server_ack = new Map<number, PendingBinaryMessage>();\n    private server_ack_tracker: AckTracker = new AckTracker();\n    private current_ack = 0;\n\n    private readonly ping_pong_formatter = CryoFrameFormatter.GetFormatter(\"ping_pong\");\n    private readonly ack_formatter = CryoFrameFormatter.GetFormatter(\"ack\");\n    private readonly error_formatter = CryoFrameFormatter.GetFormatter(\"error\");\n    private readonly utf8_formatter = CryoFrameFormatter.GetFormatter(\"utf8data\");\n    private readonly binary_formatter = CryoFrameFormatter.GetFormatter(\"binarydata\");\n\n    private crypto: CryoCryptoBox | null = null;\n    private handshake: CryoHandshakeEngine | null = null;\n    private router: CryoFrameRouter;\n\n    private constructor(private host: string, private sid: UUID, private socket: WebSocket, private timeout: number, private bearer: string, private use_cale: boolean, private log: DebugLoggerFunction = CreateDebugLogger(\"CRYO_CLIENT_SESSION\")) {\n        super();\n        if (use_cale) {\n            const handshake_events: HandshakeEvents = {\n                onSecure: ({transmit_key, receive_key}) => {\n                    this.crypto = new CryoCryptoBox(transmit_key, receive_key);\n                    this.log(\"Channel secured.\");\n                    this.emit(\"connected\", undefined); // only emit once we\u2019re secure\n                },\n                onFailure: (reason: string) => {\n                    this.log(`Handshake failure: ${reason}`);\n                    this.Destroy(CloseCode.CLOSE_CALE_HANDSHAKE, \"Failure during CALE handshake.\");\n                }\n            };\n\n            this.handshake = new CryoHandshakeEngine(\n                this.sid,\n                async (buf) => this.socket.send(buf.buffer), // raw plaintext send\n                CryoFrameFormatter,\n                () => this.current_ack++,\n                handshake_events,\n            );\n\n            this.router = new CryoFrameRouter(\n                CryoFrameFormatter,\n                () => this.handshake!.is_secure,\n                async (b) => this.crypto!.decrypt(b),\n                {\n                    on_ping_pong: async (b) => this.HandlePingPongMessage(b),\n                    on_ack: async (b) => this.HandleAckMessage(b),\n                    on_error: async (b) => this.HandleErrorMessage(b),\n                    on_utf8: async (b) => this.HandleUTF8DataMessage(b),\n                    on_binary: async (b) => this.HandleBinaryDataMessage(b),\n\n                    on_server_hello: async (b) => this.handshake!.on_server_hello(b),\n                    on_handshake_done: async (b) => this.handshake!.on_server_handshake_done(b)\n                }\n            );\n        } else {\n            this.log(\"CALE disabled, running in unencrypted mode.\");\n            this.router = new CryoFrameRouter(\n                CryoFrameFormatter,\n                () => false,\n                async (b) => b,\n                {\n                    on_ping_pong: async (b) => this.HandlePingPongMessage(b),\n                    on_ack: async (b) => this.HandleAckMessage(b),\n                    on_error: async (b) => this.HandleErrorMessage(b),\n                    on_utf8: async (b) => this.HandleUTF8DataMessage(b),\n                    on_binary: async (b) => this.HandleBinaryDataMessage(b),\n                    on_server_hello: async (_b) => this.Destroy(CloseCode.CLOSE_CALE_MISMATCH, \"CALE Mismatch. The server excepts CALE encryption, which is currently disabled.\")\n                }\n            );\n\n            setTimeout(() => this.emit(\"connected\", undefined));\n        }\n\n\n        this.AttachListenersToSocket(socket);\n    }\n\n    private AttachListenersToSocket(socket: WebSocket) {\n        if (this.use_cale) {\n            once(socket, \"message\", (msg: MessageEvent) => {\n                //If the first read frame IS NOT SERVER_HELLO, fail and die in an explosion.\n                if (!(msg.data instanceof ArrayBuffer))\n                    return;\n\n                const raw = new CryoBuffer(new Uint8Array(msg.data));\n                const type = CryoFrameFormatter.GetType(raw);\n\n                if (type !== BinaryMessageType.SERVER_HELLO) {\n                    this.log(`CALE mismatch: expected SERVER_HELLO, got ${type}`);\n                    this.Destroy(CloseCode.CLOSE_CALE_MISMATCH, \"CALE mismatch: The server has disabled CALE.\");\n                    return;\n                }\n\n                this.router.do_route(raw).then(() => {\n                    socket.addEventListener(\"message\", async (msg: MessageEvent) => {\n                        if (msg.data instanceof ArrayBuffer)\n                            await this.router.do_route(new CryoBuffer(new Uint8Array(msg.data)));\n                    });\n                })\n            });\n        } else {\n            socket.addEventListener(\"message\", async (msg: MessageEvent) => {\n                if (msg.data instanceof ArrayBuffer)\n                    await this.router.do_route(new CryoBuffer(new Uint8Array(msg.data)));\n            });\n        }\n\n        socket.addEventListener(\"error\", async (error_event) => {\n            await this.HandleError(new Error(\"Unspecified WebSocket error!\", {cause: error_event}));\n        });\n\n        socket.addEventListener(\"close\", async (close_event) => {\n            await this.HandleClose(close_event.code, new CryoBuffer((new TextEncoder().encode(close_event.reason))));\n        });\n    }\n\n    private static async ConstructSocket(host: string, timeout: number, bearer: string, sid: string): Promise<WebSocket> {\n        const full_host_url = new URL(host);\n        full_host_url.searchParams.set(\"authorization\", `Bearer ${bearer}`);\n        full_host_url.searchParams.set(\"x-cryo-sid\", sid);\n        const sck = new WebSocket(full_host_url);\n        sck.binaryType = \"arraybuffer\";\n\n        return new Promise<WebSocket>((resolve, reject) => {\n            setTimeout(() => {\n                if (sck.readyState !== WebSocket.OPEN)\n                    reject(new Error(`Connection timeout of ${timeout} ms reached!`));\n            }, timeout)\n            sck.addEventListener(\"open\", () => {\n                resolve(sck);\n            })\n            sck.addEventListener(\"error\", (err) => {\n                reject(new Error(`Error during session initialisation!`, {cause: err}));\n            });\n        })\n    }\n\n    public static async Connect(host: string, bearer: string, use_cale: boolean = true, timeout: number = 5000): Promise<CryoClientWebsocketSession> {\n        const sid: UUID = crypto.randomUUID();\n\n        const socket = await CryoClientWebsocketSession.ConstructSocket(host, timeout, bearer, sid);\n        return new CryoClientWebsocketSession(host, sid, socket, timeout, bearer, use_cale);\n    }\n\n    /*\n    * Handle an outgoing binary message\n    * */\n    private async HandleOutgoingBinaryMessage(outgoing_message: CryoBuffer): Promise<void> {\n        //Create a pending message with a new ack number and queue it for acknowledgement by the server\n        const type = CryoFrameFormatter.GetType(outgoing_message);\n        if (type === BinaryMessageType.UTF8DATA || type === BinaryMessageType.BINARYDATA) {\n            const message_ack = CryoFrameFormatter.GetAck(outgoing_message);\n            this.server_ack_tracker.Track(message_ack, {\n                timestamp: Date.now(),\n                message: outgoing_message\n            });\n        }\n\n        //Send the message buffer to the server\n        if (!this.socket)\n            return;\n\n        let message = outgoing_message;\n        if (this.use_cale && this.secure) {\n            message = await this.crypto!.encrypt(outgoing_message);\n        }\n\n        try {\n            this.socket.send(message.buffer);\n        } catch (ex) {\n            if (ex instanceof Error)\n                this.HandleError(ex).then(r => null);\n        }\n\n        this.log(`Sent ${CryoFrameInspector.Inspect(outgoing_message)} to server.`);\n\n\n    }\n\n    /*\n    * Respond to PONG frames with PING and vice versa\n    * */\n    private async HandlePingPongMessage(message: CryoBuffer): Promise<void> {\n        const decodedPingPongMessage = this.ping_pong_formatter\n            .Deserialize(message);\n\n        const ping_pongMessage = this.ping_pong_formatter\n            .Serialize(this.sid, decodedPingPongMessage.ack, decodedPingPongMessage.payload === \"pong\" ? \"ping\" : \"pong\");\n\n        await this.HandleOutgoingBinaryMessage(ping_pongMessage);\n    }\n\n    /*\n    * Handling of binary error messages from the server, currently just log it\n    * */\n    private async HandleErrorMessage(message: CryoBuffer): Promise<void> {\n        const decodedErrorMessage = this.error_formatter\n            .Deserialize(message);\n\n        this.log(decodedErrorMessage.payload);\n    }\n\n    /*\n    * Locally ACK the pending message if it matches the server's ACK\n    * */\n    private async HandleAckMessage(message: Buffer): Promise<void> {\n        const decodedAckMessage = this.ack_formatter\n            .Deserialize(message);\n        const ack_id = decodedAckMessage.ack;\n\n        const found_message = this.server_ack_tracker.Confirm(ack_id);\n\n        if (!found_message) {\n            this.log(`Got unknown ack_id ${ack_id} from server.`);\n            return;\n        }\n\n        this.messages_pending_server_ack.delete(ack_id);\n        this.log(`Got ACK ${ack_id} from server.`);\n    }\n\n    /*\n    * Extract payload from the binary message and emit the message event with the utf8 payload\n    * */\n    private async HandleUTF8DataMessage(message: Buffer): Promise<void> {\n        const decodedDataMessage = this.utf8_formatter\n            .Deserialize(message);\n\n        const payload = decodedDataMessage.payload;\n\n        const encodedAckMessage = this.ack_formatter\n            .Serialize(this.sid, decodedDataMessage.ack);\n\n        await this.HandleOutgoingBinaryMessage(encodedAckMessage);\n        this.emit(\"message-utf8\", payload);\n    }\n\n    /*\n    * Extract payload from the binary message and emit the message event with the binary payload\n    * */\n    private async HandleBinaryDataMessage(message: Buffer): Promise<void> {\n        const decodedDataMessage = this.binary_formatter\n            .Deserialize(message);\n\n        const payload = decodedDataMessage.payload;\n\n        const encodedAckMessage = this.ack_formatter\n            .Serialize(this.sid, decodedDataMessage.ack);\n\n        await this.HandleOutgoingBinaryMessage(encodedAckMessage);\n        this.emit(\"message-binary\", payload);\n    }\n\n    private async HandleError(err: Error) {\n        this.log(`${err.name} Exception in CryoSocket: ${err.message}`);\n        this.socket.close(CloseCode.CLOSE_SERVER_ERROR, `CryoSocket ${this.sid} was closed due to an error.`);\n    }\n\n    private TranslateCloseCode(code: number): string {\n        switch (code as CloseCode) {\n            case CloseCode.CLOSE_GRACEFUL:\n                return \"Connection closed normally.\";\n            case CloseCode.CLOSE_CLIENT_ERROR:\n                return \"Connection closed due to a client error.\";\n            case CloseCode.CLOSE_SERVER_ERROR:\n                return \"Connection closed due to a server error.\";\n            case CloseCode.CLOSE_CALE_MISMATCH:\n                return \"Connection closed due to a mismatch in client/server CALE configuration.\";\n            case CloseCode.CLOSE_CALE_HANDSHAKE:\n                return \"Connection closed due to an error in the CALE handshake.\";\n            default:\n                return \"Unspecified cause for connection closure.\"\n        }\n    }\n\n    private async HandleClose(code: number, reason: Buffer) {\n        this.log(`Websocket was closed. Code=${code} (${this.TranslateCloseCode(code)}), reason=${reason.toString(\"utf8\")}.`);\n\n        if (code !== CloseCode.CLOSE_GRACEFUL) {\n            let current_attempt = 0;\n            let back_off_delay = 5000;\n\n            //If the connection was not normally closed, try to reconnect\n            this.log(`Abnormal termination of Websocket connection, attempting to reconnect...`);\n            ///@ts-expect-error\n            this.socket = null;\n\n            this.emit(\"disconnected\", undefined)\n            while (current_attempt < 5) {\n                try {\n                    this.socket = await CryoClientWebsocketSession.ConstructSocket(this.host, this.timeout, this.bearer, this.sid);\n                    this.AttachListenersToSocket(this.socket);\n\n                    this.emit(\"reconnected\", undefined);\n                    return;\n                } catch (ex) {\n                    if (ex instanceof Error) {\n                        ///@ts-expect-error\n                        const errorCode = ex.cause?.error?.code as string;\n                        console.warn(`Unable to reconnect to '${this.host}'. Error code: '${errorCode}'. Retry attempt in ${back_off_delay} ms. Attempt ${current_attempt++} / 5`);\n                        await new Promise((resolve) => setTimeout(resolve, back_off_delay));\n                        back_off_delay += current_attempt * 1000;\n                    }\n                }\n            }\n\n            console.warn(`Gave up on reconnecting to '${this.host}'`)\n            return;\n        }\n\n        if (this.socket)\n            this.socket.close();\n\n        this.emit(\"closed\", [code, reason.toString(\"utf8\")]);\n    }\n\n    /*\n    * Send an utf8 message to the server\n    * */\n    public async SendUTF8(message: string): Promise<void> {\n        const new_ack_id = this.current_ack++;\n\n        const formatted_message = CryoFrameFormatter\n            .GetFormatter(\"utf8data\")\n            .Serialize(this.sid, new_ack_id, message);\n\n        await this.HandleOutgoingBinaryMessage(formatted_message);\n    }\n\n    /*\n    * Send a binary message to the server\n    * */\n    public async SendBinary(message: CryoBuffer): Promise<void> {\n        const new_ack_id = this.current_ack++;\n\n        const formatted_message = CryoFrameFormatter\n            .GetFormatter(\"binarydata\")\n            .Serialize(this.sid, new_ack_id, message);\n\n        await this.HandleOutgoingBinaryMessage(formatted_message);\n    }\n\n    public Close(): void {\n        this.Destroy(CloseCode.CLOSE_GRACEFUL, \"Client finished.\");\n    }\n\n    public get secure(): boolean {\n        return this.use_cale && this.crypto !== null;\n    }\n\n    public get session_id(): UUID {\n        return this.sid;\n    }\n\n    public Destroy(code: number = 1000, message: string = \"\") {\n        this.log(`Teardown of session. Code=${code}, reason=${message}`);\n        this.socket.close(code, message);\n    }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "cryo", "AckTracker", "ack", "message", "maybe_ack", "CryoBuffer", "_CryoBuffer", "buffer", "length", "input", "encoding", "data", "i", "buffers", "length_total", "acc", "v", "result", "offset", "buf", "value", "text", "byte", "start", "end", "target", "target_start", "GuardError", "_GuardError", "pMessage", "Guard", "_Guard", "param", "message", "expr", "CryoBufferUtil", "buffer", "uuidv4_p1", "uuidv4_p2", "uuidv4_p3", "uuidv4_p4", "uuidv4_p5", "sid", "CryoBuffer", "AckFrameFormatter", "value", "ack", "type", "payload", "msg_buf", "PingPongFrameFormatter", "UTF8FrameFormatter", "BinaryFrameFormatter", "payload_length", "ErrorFrameFormatter", "ServerHelloFrameFormatter", "Guard", "ClientHelloFrameFormatter", "HandshakeDoneFrameFormatter", "CryoFrameFormatter", "message", "encoding", "typeToStringMap", "CryoFrameInspector", "message", "encoding", "sid", "CryoFrameFormatter", "ack", "type", "type_str", "payload", "CreateDebugLogger", "section", "msg", "params", "method_cleaned", "method", "position", "CryoEventEmitter", "type", "listener", "Guard", "e", "payload", "import_key", "data", "usage", "make_algo", "iv", "CryoCryptoBox", "encrypt_key", "decryption_key", "CryoBuffer", "plain", "key", "encrypted", "cipher", "data_with_tag", "decrypted", "CryoHandshakeEngine", "sid", "send_plain", "formatter", "next_ack", "events", "ex", "frame", "decoded", "CryoFrameFormatter", "server_pub_key", "secret", "hash", "CryoBuffer", "my_pub_key", "ack", "client_hello", "done", "CryoFrameRouter", "formatter", "is_secure", "decrypt", "handlers", "log", "CreateDebugLogger", "frame", "CryoFrameFormatter", "raw", "type", "e", "once", "socket", "type", "handler", "wrapper", "ev", "CryoClientWebsocketSession", "_CryoClientWebsocketSession", "CryoEventEmitter", "host", "sid", "timeout", "bearer", "use_cale", "log", "CreateDebugLogger", "handshake_events", "transmit_key", "receive_key", "CryoCryptoBox", "reason", "CryoHandshakeEngine", "buf", "CryoFrameFormatter", "CryoFrameRouter", "b", "_b", "AckTracker", "msg", "raw", "CryoBuffer", "error_event", "close_event", "full_host_url", "sck", "resolve", "reject", "err", "outgoing_message", "message_ack", "message", "ex", "r", "CryoFrameInspector", "decodedPingPongMessage", "ping_pongMessage", "decodedErrorMessage", "ack_id", "decodedDataMessage", "payload", "encodedAckMessage", "code", "current_attempt", "back_off_delay", "errorCode", "new_ack_id", "formatted_message", "cryo", "host", "bearer", "use_cale", "timeout", "CryoClientWebsocketSession"]
}
